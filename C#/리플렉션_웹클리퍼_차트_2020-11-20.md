# 리플렉션(reflection)

- 폼에 여러 숫자 버튼이 있고, 다른 버튼을 누르면 숫자의 색깔이나 폰트가 바뀌는 프로그램을 만들고 싶다고 하자
- 우선 폼에 버튼을 많이 생성해야 하니, 테이블 레이아웃 패널을 4*4로 깔아주고, 각 레이아웃에 버튼 컨트롤을 추가해준다
- 도구 상자에 보면 대화 상자 탭이 있는데, 이 안에 ColorDialog, FontDialog등이 있다. 이들도 일종의 폼이다. 이벤트 핸들러를 통해 다른 폼을 불러올 떄 처럼 불러올 수 있다

```csharp
private void btnColor_Click(object sender, EventArgs e)
{
	if(ColorDialog1.ShowDialog() != DialogResult.OK)
		return;

	button1.BackColor = ColorDialog1.Color;
	// 2~0
}
```

- 10개의 버튼을 전부 바꿔주려면 코드를 10줄을 입력해야 하는 불편함이 있다. 그래서 버튼 컨트롤을 담을 수 있는 리스트를 만들어 값을 채워준다면 좀 더 편하지 않을까?

```csharp
private List<Button> _buttons = new List<Button>();

protected override void OnLoad(EventArgs e)
{
	base.OnLoad(e);

	_buttons.Add(button1);
	// 2~0
}

private void btnColor_Click(object sender, EventArgs e)
{
	// ...
	foreach(Button button in _buttons)
		button.BackColor = colorDialog1.Color;
}
```

- 물론 리스트를 이용해 정리하는 방법도 매우 좋지만, 여기서 리플렉션을 가져오는 코드를 쓰면 더 잘 사용할 수 있다
- 리플렉션(reflection)은 타입의 메타정보를 런타임에 얻을 수 있는 방법을 의미한다. 또는 Run-Time Type Investigate라고도 한다.
- 리플렉션은 강력하지만 속도가 느린 단점이 있으므로, 제한적으로 사용해야 한다.

```csharp
private List<Button> LoadNumberButtons()
{	
	// 1. GetType 메서드를 불러온다
	// Type : 타입에 대한 메타 정보를 가지고 있는 클래스
	Type type = GetType();
	
	// 2. GetFields 필드 정보를 찾는다
	// FieldInfo : 필드에 대한 정보를 가지고 있는 클래스
	// BindingFlags : 필드 정보에 대한 제약조건을 가진 열거형
	FieldInfo[] fieldInfos = 
	type.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);

	// 3. 값을 불러와 Button으로 캐스팅하여 리스트에 넣는다
	// 이렇게 하면 모든 버튼타입이 리스트에 들어간다
	foreach(var info in fieldInfos)
	{
		Button button = info.GetValue(this) as Button;
		if(button == null)
			continue;
		_buttons.Add(button);
	}

	// 번외. 숫자버튼 외의 다른 버튼을 여러 조건들로 제거해준다
	_buttons.Remove(btnColor);
	_buttons.Remove(btnFont);
}
```

# 웹의 정보 가져오기

- 스크랩퍼 역할을 할 콘솔 프로젝트를 만들어준다
- 데이터를 받을 데이터베이스와 테이블을 만들어주고, EF로 가져온다
  - 데이터베이스 : Kipet, 테이블 : Price, 필드 : StockCode(string), Date(DateTime), Open(decimal), Close(decimal)
- EF로 가져온 데이터베이스를 활용하기 위해 DAO 클래스등을 추가해준다

---

- 다음 금융에서 주가 값을 가져오려고 한다. 주소를 확인하기 위해서 개발자 도구(F12)로 진입하여 Network로 들어가서 다른 페이지를 눌러보면 데이터의 경로를 확인할 수 있다.
- 데이터의 경로와, Header에서 referer의 정보를 가져온다.
- WebClient 클래스 객체를 생성해서, 사이트의 소스를 가져온다

```csharp
// 웹클라이언트 개체 생성 및 인코딩 설정
WebClient web = new WebClient();
web.Encoding = Encoding.UTF8;
// Header의 referer
web.Headers["referer"] = "https://m.finance.daum.net/";
// 데이터의 경로
string url = "https://finance.daum.net/api/quote/A005930/days?perPage=10&page=2&pagination=true";
string html = web.DownloadString(url);
```

- 가져온 소스를 보니 html이 아니라 json타입이다. NuGet 솔루션 패키지 관리에서 Newtonsoft [Json.NET](http://json.NET) 라이브러리를 설치해준 다음. Json.NET 라이브러리로 가져온 소스를 역직렬화(Deseriailze) 해줘야 한다.
- 역직렬화한 데이터가 어떻게 생겼는지 모르기 때문에, 우선 동적 타입(dynamic)으로 받아서 확인한다.

```csharp
dynamic d = JsonConvert.DeserializeObject(json);
```

- 이렇게 구성한 스크래퍼를 클래스로 구성하면 이렇게 된다

```csharp
public class PriceScrapper
{
	// singleton
	public void Scrap(string stockCode, int maxPage)
	{
		Webclient web = new WebClient();
		web.Encoding = Encoding.UTF8;

		for(int page = 1; page <= maxPage; page++)
		{
			web.Headers["referer"] = "https://m.finance.daum.net/";
			string url = 
				$"https://finance.daum.net/api/quote/A{stockCode}/days?perPage=10&page={page}&pagination=true";
			string json = web.DownloadString(url);

			dynamic @object = JsonConvert.DeserializeObject(json);
			for(int i = 0;i < 10;i++)
			{
				Price price = new Price();
				price.StockCode = stockCode;
				price.Date = Convert.ToDateTime(@object.data[i].date);
				price.Date = price.Date.Date;
				price.Open = Convert.ToDecimal(@object.data[i].openingPrice);
				price.Close = Convert.ToDecimal(@object.data[i].tradePrice);

				if (Dao.Price.GetByPK(price.StockCode, price.Date) != null)
					return;

				Dao.Price.Insert(price);
			}
		}
	}
}

// Main
PriceScrapper.Instance.Scrap("005930", 10);
```

# 차트

- MS가 Dundas BI 회사를 사면서, Dundas BI에서 제공하는 차트 라이브러리의 일부를 사용할 수 있다.
- 차트도 그리드처럼 바인딩소스를 먼저 추가해주고, OnLoad로 데이터를 넣어준다.
- Series에 들어와 차트의 속성을 설정할 수 있다. 여러 속성을 사용할 경우 시리즈를 여러개 생성해 사용한다
- ChartType(차트 종류), 데이터원본(X값,Y값) 등 설정값을 설정해주면 원하는 형태의 차트가 나온다