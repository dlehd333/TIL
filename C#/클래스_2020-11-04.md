(C++에서 동일하게 사용되는 내용은 생략되었다)

---

# 프로퍼티(property)

- 캡슐화를 위해 클래스의 필드를 private로 선언하고, 데이터 사용이 필요할 경우 getter나 setter 메서드를 사용하고는 한다. 하지만 이 부분이 생각보다 귀찮고 번거로우며, 굳이 이렇게 해야하나 싶은 유혹이 든다.
- 그래서 필드의 은닉성과 접근의 편의성을 모두 잡을 수 있는 형태가 프로퍼티(property)이다.
- 기본적으로 필드를 선언하고, 해당 필드에 대한 프로퍼티를 선언해 사용할 수 있다. 예제에는 get과 set이 있지만, 읽기전용으로 쓰기 원한다면 set을 안쓰면 된다.
- 이렇게 프로퍼티에서 제어하는 필드를 backing field라고 부른다.

```csharp
// Property의 기본적인 사용 예
class MyClass
{
	private int myField;
	public int MyField   // 이름이 다름에 주의
	{
		get
		{
			return myField;
		}
		set
		{
			myField = value; // value는 수식으로 받은 값을 의미한다
		}
	}
}
```

- 만일 사용하는 필드에 단순히 읽고 쓰는 기능만 있다면, 아예 프로퍼티로 바로 선언하여 사용할 수도 있다.
- 이렇게 필드를 선언하지 않고 사용하면, 프로퍼티에 임의로 backing field가 자동으로 선언되어 사용된다.

```csharp
public int MyField
{
	get; set;
}
// (7.0)선언과 동시에 초기화가 가능
public int MyField {get; set;} = 100;
```

- 프로퍼티로 사용할 경우, 객체를 생성할 때 생성자를 통해 프로퍼티의 초기화가 가능하다.

```csharp
// 생성자에 초기화를 정의할 수 있다
public class MyClass
{
	MyClass()
	{
		MyField = 100;
	}
	// ...
}
// 인스턴스를 생성할 때 원하는 프로퍼티의 초기값을 설정할 수 있다
MyClass my = new MyClass()
{
	MyField = 100, MyField2 = 200
};
```

# 정적 필드와 정적 메서드(static)

- static은 메서드나 필드가 클래스 자체에 소속되도록 지정하는 한정자이다.
- 필드나 메서드에 static을 선언하면, 해당 필드나 메서드는 생성한 인스턴스의 소속이 아닌, 클래스 내부의 속성이 되며. 그 값은 프로그램 전체에 공유할 수 있다. 이를 정적 맴버(static member)라고 부른다
- 정적 맴버의 반대말은 instance member또는 non-static member라고 부른다

```csharp
class MyClass
{
	public static int a;
	public int b;
	public static void func() { // ... }
}

static void Main()
{
	MyClass my;
	my.b = 1; // 인스턴스 소속의 일반 필드
	MyClass.a = 1; // 클래스 소속의 정적 필드. 인스턴스를 만들지 않고 직접 접근.
	MyClass.func(); // 클래스 소속의 정적 메서드
}
```

- 정적 매서드에서 정적 필드의 값을 불러오거나 변경할 수 있다, 그러나 정적 메서드에서 인스턴스 필드의 값을 불러오거나 변경할 수 없다.
- 인스턴스 메서드에서 인스턴스 필드의 값을 불러오거나 변경할 수 있다, 하지만 인스턴스 메서드에서 정적 필드의 값을 불러올 수는 있지만 값을 변경할 수 없다.

```csharp
public static int staticInt;
public int instanceInt;
// 정적 메서드에서는 정적 필드만 사용 및 수정 가능
public static void StaticFunc()
{
	staticInt += 10;
	instanceInt = staticInt; // error
}
// 인스턴스 메서드에서는 정적 필드와 인스턴스 필드 둘 다 사용 가능
// 하지만, 값 변경은 인스턴스 필드만 가능
public void InstanceFunc()
{
   instanceInt = staticInt;
}
```



# 오버라이드

- 상속받은 자식 클래스는 부모 클래스의 매소드를 사용할 수 있게 되는데, 부모 클래스가 메서드를 가상 함수로 지정하면, 자식 클래스가 부모 클래스의 메서드를 자신의 상황에 맞게 수정하여 사용할 수 있다. 이를 오버라이드(재정의)라고 한다.

```csharp
// 부모 클래스
public virtual void What() { } // virtual -> 변경 가능한, 가상함수
// 자식 클래스
public override void What() { } // override -> 변경한, 재정의된
```

- 부모 클래스는 자식 클래스를 자기 자신으로 간주하여 생성하는 것이 가능하고, 함수의 매개 변수에도 사용 가능하다.

```csharp
// 부모 클래스 : Unit, 자식 클래스 : Marine, Zelot
Unit m = new Marine();
Unit z = new Zelot();
What(m);
What(z);

public void What(Unit u) { // ... }
```

- 부모 클래스에 내용이 없고 재정의 가능한 함수를 만들 수 있는데, 이를 추상 함수라고 부른다. 가상 함수와 다른 점은 "내용이 없다"는 점이다. 그래서 자식 클래스는 무조건 오버리아드를 해야 한다.

```csharp
// 부모 클래스
abstract class MyClass{
public abstract void getDamaged(int damage);
// 자식 클래스
class MyClass2 : MyClass{
public override void getDamaged(int damage) { }
```

- 1개 이상의 추상 매소드를 가진 클래스는 추상 클래스라고 부른다.
- 추상 클래스는 자기 자신을 생성하는 것이 불가능하다.

```csharp
Unit u = new Unit(); // error
```

# 인덱서

- 인덱스를 이용해 객체 내 데이터에 접근하게 하는 프로퍼티이다

```csharp
// 인덱서 선언 형식 및 예제
public int this[int index]
{
	get { return array[index]; }
	set { return array[index] = value; }
}
```

- 6.0에서 추가된 Expression-bodied Member를 사용하면, 길이를 줄일 수 있다. 이는 속성/메서드의 본문(Body블록)이 하나의 문장으로 끝나는 단순한 경우에 사용할 수 있다. 람다 화살표(⇒)를 통해 여러 형식을 간단히 정의할 수 있다.(인덱서는 7.0에 추가되었다)

```csharp
// 인덱서에서 get만 사용할 경우
public int this[int index] => array[index];
```