# 반복자(iterator) 패턴 - foreach

- 여러 개의 데이터가 모여있는 컬렉션(자료구조)은 그 종류가 다양하며, 그 모두가 "순서"를 가지고 있지는 않다.
- 그래서 순서를 이용해 반복을 진행하는 기존의 for문으로는 순회가 불가능하거나 어려운 컬렉션이 존재한다

```csharp
// 집합 컬렉션인 HashSet, 중복 요소를 포함하지 않고 해당 요소가 특정 순서로 정렬 되어 있지 않다
HashSet<int> set = new HashSet<int>{1,2,3,4};
for(int i = 0;i < set.Count;i++)
	Console.WriteLine(set[i]); // error
```

- 그래서 이를 해결하기위해 고안된 디자인 패턴이 '반복자(iterator)' 패턴이며, C#에는 foreach문으로 바로 사용할 수 있도록 가져온 형태인 것이다
- foreach문은 ```foreach([데이터형식] [변수명] in [컬렉션])```처럼 사용한다

```csharp
HashSet<int> set = new HashSet<int>{1,2,3,4};
foreach(int x in set)
	Console.WriteLine(x);
```

# 싱글톤(singleton) 패턴

- 클래스의 객체를 단 하나만 만들어야 하는 경우에 사용한다. 그렇게 되면 클래스 내에서 인스턴스가 단 하나뿐임을 보장하므로, 프로그램 전역에서 해당 클래스의 인스턴스를 바로 얻을 수 있고, 불필요한 메모리 낭비를 최소화한다
- C#에서 싱글톤 패턴을 사용하기 위해서는, 1. 생성자를 접근하지 못하도록 private로 설정하고, 2. 자기 자신을 private static 으로 선언하고 3. 프로퍼티로 자기 자신을 반환해준다.
- C#에서 싱글톤 패턴을 사용할 때는, ```[클래스명].[인스턴스명].[함수/프로퍼티]```의 형태로 사용할 수 있다.

```csharp
private Marine() { } // 외부에서의 생성을 막는다
private static Marine _instance; // 자기 자신을 정적 필드로 선언한다
public static Marine Instance // 정적 필드에 접근할 수 있게 정적 프로퍼티를 사용한다
{
	get
	{
		if(_instance == null)
			_instance = new Marine(); // 처음 호출할 떄 딱 한번 생성된다
		return _instance;
	}
}
public void foo() { }
// 싱글톤 패턴으로 생성한 객체(정적 필드)를 사용
Marine.Instance.foo();
```

- 클래스의 맴버 자체를 정적 맴버로 사용하지 않고 위처럼 자기 자신을 선언하여 사용하는 이유는, non-static 맴버 또는 상속을 받은 가상 함수(오버라이딩)를 사용할 수 없기 때문이다.