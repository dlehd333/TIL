# 두 개 뽑아서 더하기
- 코딩테스트 연습 > 월간 코드 챌린지 시즌1 > 두 개 뽑아서 더하기
---
# 문제
정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.
## 제한사항
numbers의 길이는 2 이상 100 이하입니다.
numbers의 모든 수는 0 이상 100 이하입니다.
## 입출력 예
numbers	result
[2,1,3,4,1]	[2,3,4,5,6,7]
[5,0,2,7]	[2,5,7,9,12]
## 입출력 예 설명
### 입출력 예 #1
2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.)
3 = 2 + 1 입니다.
4 = 1 + 3 입니다.
5 = 1 + 4 = 2 + 3 입니다.
6 = 2 + 4 입니다.
7 = 3 + 4 입니다.
따라서 [2,3,4,5,6,7] 을 return 해야 합니다.
### 입출력 예 #2
2 = 0 + 2 입니다.
5 = 5 + 0 입니다.
7 = 0 + 7 = 5 + 2 입니다.
9 = 2 + 7 입니다.
12 = 5 + 7 입니다.
따라서 [2,5,7,9,12] 를 return 해야 합니다.
# 나의 풀이
```python
def solution(numbers):
    answer = []
    # numbers에서 다른 인덱스에 있는 두 개의 수를 뽑아 더하기
    for in1 in range(0, len(numbers)):
        for in2 in range(0, len(numbers)):
            # 같은 인덱스는 계산하지 않음
            if in1 == in2:
                continue
            # 두개의 수를 더함
            sum = numbers[in1] + numbers[in2]
            # 더한 수가 배열에 있는지 확인
            cross = False
            for k in answer:
                if sum == k:
                    cross = True
                    break
            # 배열에 없다면 추가
            if cross == False:
                answer.append(sum)
    # 추가가 끝난 배열을 정렬
    answer.sort()
    return answer
```
# 모든 풀이를 확인하며 고칠점
## 1. 이중 for문을 사용한 범위가 비효율적이었다
   - 모든 변수 x 모든 변수로 범위를 잡았는데, 첫번째 변수가 두번째 변수부터 마지막 변수까지 탐색했다면 두번째 변수는 첫번째 변수를 탐색할 필요가 없어진다(첫번째 변수가 두번째 변수와 계산을 완료했기 때문)
   - 또한, 내가 작성한 코드처럼 같은 인덱스 여부를 계산할 필요도 없어진다
   - 그러므로 for문의 범위를 모든 변수 x 앞 변수+1 부터로 잡는게 더 효율적이다
```python
# 모든변수 x 모든변수
for i in range(len(numbers))
    for j in range(len(numbers))
# 모든변수 x 앞변수+1 부터 모든변수
for i in range(len(numbers))
    for j in range(i+1, len(numbers))
```
## 2. 파이썬의 set 속성을 사용해야 했다
   - 집합 자료형(set)의 특징 중에 __"중복을 허용하지 않는다"__ 가 있다.
   - 이를 이용해 굳이 리스트에 넣을 때 마다 입력하지 않아도, set으로 한번 변형해주면 중복값이 사라진다.
   - 그러면, 값을 넣을 때 마다 중복여부를 확인하려고 탐색할 필요가 없어진다
   - 실제로도, set은 교집합, 합집합, 차집합 등에 사용한다고 한다
```python
sum_set = set([])
# ...
sum_set.add(numbers[i]+numbers[j]) # 이렇게 써도 중복을 걸러내더라
# ...
return sorted(list(sum_set))
```
## 3. 파이썬의 정렬 함수가 있다
   - 중간에 검색하다가 발견해서 사용했지만, 몰랐던 내용이므로 적는다
   - list.sort()를 사용하면 오름차순으로 정렬된다
   - 위의 set과 함께 사용하려면 sorted()를 사용하면 된다
```python
sorted(list(set(answer)))
# set함수 사용으로 중복 없는 집합 자료형으로 변환
# 집합 자료형을 다시 인덱싱있는 리스트로 사용하기 위해 list함수 사용
# 이후 sorted함수 사용으로 정렬하면 원하는 결과값을 도출 가능
```
## 4. 파이썬의 조합 함수가 있다
   - 조합이란 n개의 원소를 사용해 순서의 관계없이 r개의 배열로 나타내는 것을 말한다. 즉, 순서에 상관없이 r개의 배열로 나타낼 수 있는 형태를 조합이라고 한다.
   - 파이썬에는 조합을 구해주는 외장함수가 있다. 이를 사용하면 순서 차이로 인한 중복값을 제외한 모든 조합을 구할 수 있다
```python
from itertools import combinations
# ...
l = list(combinations(numbers, 2)) # 조합을 구해 리스트 형태로 저장
for i in l:
    answer.append(i[0]+i[1]) # 리스트를 반복하며 모든 조합의 합을 구해 저장
```
## 5. 중복검사 또한 간단한 방법이 있었다
   - 앞의 예제를 사용하면 검사 할 필요가 없기는 하지만, 검사하는 방법 또한 간단한 방법이 있었다
   - 검사를 위해 boolean변수에 for문까지 사용했는데, if문 하나로 해결한 예제가 있더라
   - 내가 너무 c언어에 갇혀있는건 아닌가 걱정된다
```python
# 예제1
if numbers[i]+numbers[j] in answer:
    continue
# 예제2
if not sum in answer:
    answer.append(sum)
```
## 6. 파이썬은 참 편한 프로그램이다
   - 한 문제를 풀면서 발견한 유용한 함수 및 객체가 꽤 된다
   - 그리고, 다른분들의 풀이를 봤을 때 그러한 함수 및 객체의 사용을 절대 자제하지 않는다
   - 함수를 모르는 탓도 있지만, 너무 함수를 쓰지 않으려고 한 것도 있다. 마치 함수로 정렬하면 나쁘게 나올 것 같다는 인식이 강했다.
   - 물론 점수까지 확인할수는 없지만, 적절한 함수 사용은 나쁘지많은 않다는 것을 다시 느꼈다
# [출제 해설](https://prgms.tistory.com/29)
## 출제의도
주어진 로직을 그대로 구현할 수 있는지
반복문을 적절하게 활용할 수 있는지
## 해설
2중 반복문을 활용하여 서로 다른 인덱스에 있는 두 수를 더해서 만들 수 있는 모든 수를 찾아서 새로운 배열에 저장합니다. 이제 새로운 배열에 있는 모든 수들 중 중복되는 수들을 제거해 하나만 남겨야 합니다. 정렬을 하거나, 또는 hashset, balanced binary tree 등의 자료구조를 사용해서 뽑아낼 수 있습니다. 시간 복잡도는 O(n2logn)입니다. (n은 numbers의 길이)