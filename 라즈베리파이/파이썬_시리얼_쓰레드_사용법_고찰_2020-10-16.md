# 001 수신과 송신을 동시에 하고싶다
- 아두이노와 라즈베리파이의 UART통신을 진행하면서 느낀 불편한 점이 있었다
- 바로, 입력과 출력을 동시에 진행하기 힘들다는 점이었다.
- 기본적으로 ```read```와 write하기 위해 값을 입력받는 ```input```구문에서 블로킹 상태가 된다
- 그래서 처음에는 단순하게, 둘 다 쓰레드로 만들면 어떨지 생각한다

# 002 쓰레드의 문제점
- 배운 내용을 최대한 활용하여, 쓰레드를 두개 만들고 하나는 입력기능, 하나는 출력기능을 넣었다
- 입력은 ```input```으로 값을 입력받아, 입력받은 값을 보낸다
- 출력은 ```read```로 읽어들인 값을 받아 출력해준다
- 물론, 수신과 송신이 겹치면서 출력값을 받으면 입력값 입력이 끊기거나 하는 등의 문제가 있지만 이 부분은 UI적 문제이고 작동 자체는 문제가 없어서 괜찮다고 생각했다
- 하지만 문제는 프로그램 종료 시 일어났다.
- 프로그램을 키보드 인터럽트로 종료하자, 쓰레드 종료를 위해 걸어둔 ```join```이후 멈춰버렸다.
- 조사 결과, ```input```과 ```read```에서 블로킹 상태가 일어나 쓰레드 종료 변수를 설정했음에도 종료되지 않는 것이었다
- 결국, 수업 담당 선생님께 상담한 결과, 쓰레드 미사용과 인터럽트가 대안으로 나왔다

# 003 인터럽트
- 먼저, ```input```구문을 보함한 입력 구문은 아예 쓰레드를 사용하지 않고 메인 부분에 작성했다.
- 그리고, ```read``` 부분에 대한 인터럽트가 있는지 여러가지로 검색하기 시작했다
- 파이썬 serial(pyserial) 라이브러리에서 인터럽트에 관한 내용이 있을까 찾아봤지만 큰 수확은 없었다. readable()이라는 함수가 존재했지만, 내가 생각하는 이벤트를 검사하는 함수는 아니었다.
```python
if readable():
    # 왜인지, 프로그램이 실행되면 계속 readable()은 True를 반환한다
```
- 또한, read함수가 버퍼를 읽어들이는 것 같아, 버퍼에 대한 인터럽트도 찾아보았지만 찾지를 못했다.

# 004 Timer, Event
- 인터럽트는 조금 어렵다는 판단이 들었다
- 그래서, 대안으로 쓰레드로 ```read```구문을 사용하면서 중간에 read의 블로킹이 깨질 수 있는 방법이 있는지 찾기 시작했다
- 첫 대안으로 찾은것은, threading 라이브러리에서 제공하는 Timer, Event 함수였다
- 처음에는 Timer가 지정한 시간이 지나면 Event가 활성화되는 구문을 보고, Timer가 Event를 일으켜 블로킹 상태에서 빠져나올 수 있을 거라고 생각했지만, 생각대로 되지 않았다
- 이 부분은 좀 더 연구가 필요하겠다 싶었고, 생각처럼 모양이 나오지 않을 것 같아서 다른 방법을 찾기 시작했다 

# 005 timeout
- 그러다 찾게 된 두 번쨰 대안은 timeout이었다
- read가 timeout에 지정된 시간만큼 읽지 않으면 블로킹이 해제되는 것이었다. 참고로 timeout이 0이면 논블로킹 모드, 1이면 1초 후 블로킹 해제, None이면 무한정 블로킹 상태이다
- 그래서 처음에는 타임아웃을 조절하지 않고, 종료 시점에서 타임아웃을 조절하여 블로킹을 해제해보려 했다
- 그래서 pyserial 라이브러리 내에 timeout함수가 있는 것 같아 사용해봤는데, 오류가 떳다
```python
ser.timeout(1.0)
# ... 'Nonetype' object is not callable
```
- 검색해보니, 타입이 맞지 않거나 함수명과 변수명이 겹치면 생기는 문제라고 한다
- 그래서 다시 찾아보니 timeout함수가 아닌 변수가 존재했고, 변수를 조절하니 값이 변경되는 것을 확인할 수 있었다
```
ser.timeout = 1.0
```
- 하지만 그럼에도 불구하고 블로킹은 해결되지 않았다
- 꽤 긴 시간 이리저리 테스트 해 본 결과, 나의 예상 결론은 **read 함수로 인해 블로킹이 걸려있는 동안에는 timeout값이 바뀌어도 read함수에 바로 적용되지 않는다**는 것이었다

# 006 대안
- 결국 생각한 다른 대안은, pyserial 라이브러리 자체에서 **버퍼에서 읽어들일 값이 있는지 검사**하는 함수나 매서드가 필요했다.
- 다시 라이브러리 문서를 찾아보는 중에, '뭔가가 쓰여지는 동안 직렬 장치에서 데이터를 읽는 것'이라는 구문과 함께 못보던 [예제](https://pythonpedia.com/ko/tutorial/5744/-----------pyserial-)를 발견했다.
```python
#for python2.7
data = ser.read(ser.inWaiting())

#for python3
ser.read(ser.inWaiting)
```
- ```inWaiting()```에 대해 확인해보니 입력 버퍼의 값의 크기를 출력하는 메서드였고, 이 메서드를 read안에 입력하니 자동으로 read의 블로킹이 풀리는 것을 확인했다
- 또한, 함수 자체가 크기값을 리턴하기 때문에 read함수 바깥에  if문으로 사용해도 작동하는 것을 확인했다
```python
if inWaiting() > 0:
    data = ser.read()
```
# 007 결론
- 결국 가장 이상적인 방법인 **인터럽트(이벤트)로 read 구문을 수행하는** 방법은 찾지 못했다
- 그래도, pyserial 라이브러리 내에서 블로킹을 어느정도 보완할 방법을 찾아서 사용할 수 있었다
- 이 방법으로 읽기와 쓰기를 동시에 진행하면서, 프로세스 종료 시 쓰레드가 종료되지 않는 현상도 해결할 수 있었다
```python
# read 구문(쓰레드)
whlie True:
    if ser.inWaiting(): # 버퍼에 읽을 값이 있을 떄
        res = ser.readline()    # 읽기 수행
        print(res.decode())  # 읽은 BYTE 타입 값을 디코딩하여 출력
    if thread_close == 1:   # 프로세스 종료 시 쓰레드 종료 변수를 1로 만들어
        break   # 쓰레드 함수가 종료되도록 유도
```
```python
# write 구문(메인)
while True:
    outs = input()  # 입력값을 입력받아
    ser.write(outs.encode())    # BYTE 타입으로 변환하여 전송
```
